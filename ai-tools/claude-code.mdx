---
title: "Claude Code setup for StackForge"
description: "Configure Claude Code for developing with the StackForge boilerplate"
icon: "robot"
---

Use Claude Code to help develop and maintain your StackForge application. This guide shows how to configure Claude Code for better results when working with the StackForge codebase.

## Prerequisites

- Claude Code extension installed in your IDE
- StackForge repository cloned locally
- Bun package manager installed
- PostgreSQL database set up

## Project context

Provide Claude Code with context about the StackForge project to improve its understanding of the codebase and provide better assistance.

### Project overview

StackForge is an AI-powered social media marketing platform built with:
- Next.js 14 with App Router
- TypeScript with strict mode enabled (`verbatimModuleSyntax` enabled)
- Tailwind CSS for styling with custom configurations
- Drizzle ORM with PostgreSQL for database operations
- Clerk for authentication and user management
- Bun as the package manager and runtime

### Key directories and file structure

Help Claude Code understand the important directories and their purposes in StackForge:

- `src/app/` - Next.js app router pages, organized in route groups like `(main)`, `(marketing)`, `auth`, and `api`
- `src/components/` - React components organized by purpose: `auth`, `dashboard`, `global`, `marketing`, `ui`
- `src/db/schema/` - Database schema definitions using Drizzle ORM
- `src/schema/` - Validation schemas using Zod for form and API validation
- `src/hooks/` - Custom React hooks for reusable logic
- `src/functions/` - Utility functions and helpers
- `src/constants/` - Application constants and configuration values
- `src/lib/` - Library configurations and clients (database, etc.)
- `drizzle/` - Database migration files generated by Drizzle Kit

### Technology patterns and conventions

Make Claude Code aware of key patterns and conventions in StackForge to ensure generated code follows the established standards:

1. **Authentication**: Uses Clerk with protected routes via middleware
   - Authentication state is managed through Clerk's React context
   - Protected routes redirect unauthenticated users to sign-in pages
   - Authenticated users are redirected from auth routes to the dashboard

2. **Database**: Uses Drizzle ORM with PostgreSQL
   - Database schema is defined in `src/db/schema/` with relations
   - Queries use Drizzle's query builder patterns
   - Environment variables are accessed using bracket notation: `process.env["VAR_NAME"]`
   - All database operations should include proper error handling

3. **Styling**: Uses Tailwind CSS with custom configurations
   - Utility classes are the primary styling method
   - Custom utilities and theme extensions are defined in `tailwind.config.ts`
   - CSS variables are used for consistent theming
   - Both dark and light mode support is implemented

4. **State Management**: Uses React Context API and hooks
   - Global state is managed through context providers
   - Custom hooks encapsulate reusable logic and state
   - Component-level state uses React's built-in hooks

5. **Form Handling**: Uses React Hook Form with Zod validation
   - Forms are built with `react-hook-form` for state management
   - Validation schemas are defined with Zod in `src/schema/`
   - Form components follow the established UI patterns

6. **UI Components**: Uses a combination of custom components and third-party libraries
   - UI components are built using Radix UI primitives for accessibility
   - Components follow the Container-Component pattern
   - Variants are managed with `class-variance-authority`
   - Components are organized following Atomic Design principles

7. **API Routes**: Follow RESTful conventions with proper error handling
   - API routes are placed in `src/app/api/` following Next.js App Router conventions
   - Routes implement proper HTTP status codes
   - Input validation is performed using Zod schemas
   - Error responses follow a consistent format

8. **TypeScript Best Practices**:
   - Strict mode is enabled with `noImplicitAny` and other strict checks
   - All type imports use the `type` modifier when `verbatimModuleSyntax` is enabled
   - Explicit return types are defined for functions
   - TypeScript path aliases (`@/*`) are used for imports

## Best practices for Claude Code interactions

### When working with components

- Follow the existing component structure and patterns in `src/components/`
- Use TypeScript interfaces for props with explicit typing
- Implement proper error handling with try/catch blocks where appropriate
- Use Tailwind CSS utility classes for styling with custom configurations
- Export components properly in `index.ts` files when creating new component groups
- Follow the Container-Component pattern where containers handle data fetching and logic
- Use proper accessibility attributes (ARIA) for interactive elements
- Implement loading states and skeleton screens for data-fetching components

### When working with database code

- Use Drizzle ORM query patterns (e.g., `db.select().from()`, `db.insert().values()`)
- Always implement proper error handling for database operations with try/catch
- Use server components for data fetching when possible to leverage SSR/SSG benefits
- Follow validation patterns with Zod schemas defined in `src/schema/`
- Use relations properly when querying related data
- Access environment variables with bracket notation: `process.env["DATABASE_URL"]`
- When extending schemas, run `bun run db:generate` to create migrations

### When working with API routes

- Place routes in the `src/app/api/` directory following Next.js App Router conventions
- Use proper HTTP methods (GET, POST, PUT, DELETE) for RESTful operations
- Implement proper error handling and status codes (200, 201, 400, 404, 500)
- Validate all input data using Zod schemas from `src/schema/`
- Return JSON responses with consistent structure
- Implement proper authentication checks for protected endpoints
- Use NextResponse for consistent response handling

### When working with authentication

- Use Clerk's authentication utilities and React hooks
- Protect pages using middleware configuration in `middleware.ts`
- Implement proper redirects for authentication states
- Use Clerk components for sign-in/sign-up flows
- Access user information through Clerk's auth context

## Available scripts and commands

Make Claude Code aware of the available development commands to provide accurate guidance on running tasks:

- `bun run dev` - Start the development server
- `bun run build` - Create a production build
- `bun run start` - Start the production server
- `bun run lint` - Run ESLint for code quality checks
- `bun run format` - Format code with Prettier
- `bun run db:push` - Push schema changes directly to database (development only)
- `bun run db:generate` - Generate migrations from schema changes
- `bun run db:migrate` - Apply migrations to the database
- `bun run db:studio` - Open Drizzle Studio for database management
- `bun run db:seed` - Seed the database with sample data

## Common StackForge tasks with examples

### Creating a new page

1. Create a new directory in `src/app/` following the route group structure
2. Add a `page.tsx` file with the page content using TypeScript
3. Add a `layout.tsx` file if needed for page-specific layouts
4. Implement proper TypeScript typing for props and state
5. Use Tailwind CSS for styling with the established design system
6. Use server components for data fetching when possible
7. Implement proper error handling and loading states

Example page structure:
```tsx
// src/app/(main)/example/page.tsx
import { ExampleComponent } from "@/components/example";

export default function ExamplePage() {
  return (
    <div className="container py-8">
      <h1 className="text-2xl font-bold">Example Page</h1>
      <ExampleComponent />
    </div>
  );
}
```

### Creating a new component

1. Determine the appropriate directory in `src/components/` based on component purpose
2. Create a new `.tsx` file with the component using TypeScript
3. Use TypeScript interfaces for props with explicit typing
4. Implement the component with proper error handling and accessibility
5. Use Tailwind CSS for styling following the design system
6. Export the component properly for use in other files
7. Add the component to the relevant `index.ts` export file

Example component structure:
```tsx
// src/components/example/example-component.tsx
import { cn } from "@/functions";

interface ExampleComponentProps {
  title: string;
  description?: string;
  className?: string;
}

export function ExampleComponent({ 
  title, 
  description, 
  className 
}: ExampleComponentProps) {
  return (
    <div className={cn("bg-background rounded-lg p-4", className)}>
      <h2 className="text-xl font-semibold">{title}</h2>
      {description && <p className="text-muted-foreground">{description}</p>}
    </div>
  );
}
```

### Extending the database schema

1. Add new models to `src/db/schema/` following existing patterns
2. Define relations using Drizzle's relations function
3. Export the new schema in `src/db/schema/index.ts`
4. Run `bun run db:generate` to create migrations
5. Run `bun run db:migrate` to apply migrations to the database
6. Create new API routes to interact with the data if needed
7. Update TypeScript types as needed in related components

Example schema extension:
```ts
// src/db/schema/example.ts
import { pgTable, text, timestamp, uuid } from "drizzle-orm/pg-core";
import { users } from "./user";
import { relations } from "drizzle-orm";

export const examples = pgTable("examples", {
  id: uuid("id").defaultRandom().primaryKey(),
  userId: uuid("user_id")
    .notNull()
    .references(() => users.id),
  title: text("title").notNull(),
  content: text("content"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const examplesRelations = relations(examples, ({ one }) => ({
  user: one(users, {
    fields: [examples.userId],
    references: [users.id],
  }),
}));
```

### Adding authentication protection

1. Use Clerk's `auth()` function or `getAuth()` to check authentication status
2. Redirect unauthenticated users to the sign-in page using `redirect()`
3. Protect API routes by checking authentication in the route handler
4. Use proper error handling for authentication failures
5. Access user information through Clerk's auth context in components

Example page protection:
```tsx
// src/app/(main)/protected/page.tsx
import { auth } from "@clerk/nextjs";
import { redirect } from "next/navigation";

export default function ProtectedPage() {
  const { userId } = auth();
  
  if (!userId) {
    redirect("/auth/signin");
  }
  
  return (
    <div className="container py-8">
      <h1 className="text-2xl font-bold">Protected Page</h1>
      <p>This page is only accessible to authenticated users.</p>
    </div>
  );
}
```

### Creating API routes

1. Create route files in `src/app/api/` following Next.js App Router conventions
2. Implement proper HTTP methods (GET, POST, PUT, DELETE)
3. Validate input data using Zod schemas
4. Use Drizzle ORM for database operations
5. Implement proper error handling and status codes
6. Return JSON responses with consistent structure

Example API route:
```ts
// src/app/api/examples/route.ts
import { NextResponse } from "next/server";
import { z } from "zod";
import { db } from "@/db";
import { examples } from "@/db/schema";

const createExampleSchema = z.object({
  title: z.string().min(1),
  content: z.string().optional(),
});

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const parsed = createExampleSchema.parse(body);
    
    const result = await db.insert(examples).values(parsed).returning();
    
    return NextResponse.json(result[0], { status: 201 });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: "Invalid request data", details: error.errors },
        { status: 400 }
      );
    }
    
    return NextResponse.json(
      { error: "Failed to create example" },
      { status: 500 }
    );
  }
}
```