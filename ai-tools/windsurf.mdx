---
title: "Windsurf setup for StackForge"
description: "Configure Windsurf for developing with the StackForge boilerplate"
icon: "wind"
---

Use Windsurf to help develop and maintain your StackForge application. This guide shows how to configure Windsurf for better results when working with the StackForge codebase.

## Prerequisites

- Windsurf editor installed
- StackForge repository cloned locally
- Bun package manager installed
- PostgreSQL database set up

## Project context

Provide Windsurf with context about the StackForge project to improve its understanding of the codebase and provide better assistance.

### Project overview

StackForge is an AI-powered social media marketing platform built with:
- Next.js 14 with App Router
- TypeScript with strict mode enabled (`verbatimModuleSyntax` enabled)
- Tailwind CSS for styling with custom configurations
- Drizzle ORM with PostgreSQL for database operations
- Clerk for authentication and user management
- Bun as the package manager and runtime

### Key directories and file structure

Help Windsurf understand the important directories and their purposes in StackForge:

- `src/app/` - Next.js app router pages, organized in route groups like `(main)`, `(marketing)`, `auth`, and `api`
- `src/components/` - React components organized by purpose: `auth`, `dashboard`, `global`, `marketing`, `ui`
- `src/db/schema/` - Database schema definitions using Drizzle ORM
- `src/schema/` - Validation schemas using Zod for form and API validation
- `src/hooks/` - Custom React hooks for reusable logic
- `src/functions/` - Utility functions and helpers
- `src/constants/` - Application constants and configuration values
- `src/lib/` - Library configurations and clients (database, etc.)
- `drizzle/` - Database migration files generated by Drizzle Kit

### Technology patterns and conventions

Make Windsurf aware of key patterns and conventions in StackForge to ensure generated code follows the established standards:

1. **Authentication**: Uses Clerk with protected routes via middleware
   - Authentication state is managed through Clerk's React context
   - Protected routes redirect unauthenticated users to sign-in pages
   - Authenticated users are redirected from auth routes to the dashboard

2. **Database**: Uses Drizzle ORM with PostgreSQL
   - Database schema is defined in `src/db/schema/` with relations
   - Queries use Drizzle's query builder patterns
   - Environment variables are accessed using bracket notation: `process.env["VAR_NAME"]`
   - All database operations should include proper error handling

3. **Styling**: Uses Tailwind CSS with custom configurations
   - Utility classes are the primary styling method
   - Custom utilities and theme extensions are defined in `tailwind.config.ts`
   - CSS variables are used for consistent theming
   - Both dark and light mode support is implemented

4. **State Management**: Uses React Context API and hooks
   - Global state is managed through context providers
   - Custom hooks encapsulate reusable logic and state
   - Component-level state uses React's built-in hooks

5. **Form Handling**: Uses React Hook Form with Zod validation
   - Forms are built with `react-hook-form` for state management
   - Validation schemas are defined with Zod in `src/schema/`
   - Form components follow the established UI patterns

6. **UI Components**: Uses a combination of custom components and third-party libraries
   - UI components are built using Radix UI primitives for accessibility
   - Components follow the Container-Component pattern
   - Variants are managed with `class-variance-authority`
   - Components are organized following Atomic Design principles

7. **API Routes**: Follow RESTful conventions with proper error handling
   - API routes are placed in `src/app/api/` following Next.js App Router conventions
   - Routes implement proper HTTP status codes
   - Input validation is performed using Zod schemas
   - Error responses follow a consistent format

8. **TypeScript Best Practices**:
   - Strict mode is enabled with `noImplicitAny` and other strict checks
   - All type imports use the `type` modifier when `verbatimModuleSyntax` is enabled
   - Explicit return types are defined for functions
   - TypeScript path aliases (`@/*`) are used for imports

## Best practices for Windsurf interactions

### When working with components

- Follow the existing component structure and patterns in `src/components/`
- Use TypeScript interfaces for props with explicit typing
- Implement proper error handling with try/catch blocks where appropriate
- Use Tailwind CSS utility classes for styling with custom configurations
- Export components properly in `index.ts` files when creating new component groups
- Follow the Container-Component pattern where containers handle data fetching and logic
- Use proper accessibility attributes (ARIA) for interactive elements
- Implement loading states and skeleton screens for data-fetching components

### When working with database code

- Use Drizzle ORM query patterns (e.g., `db.select().from()`, `db.insert().values()`)
- Always implement proper error handling for database operations with try/catch
- Use server components for data fetching when possible to leverage SSR/SSG benefits
- Follow validation patterns with Zod schemas defined in `src/schema/`
- Use relations properly when querying related data
- Access environment variables with bracket notation: `process.env["DATABASE_URL"]`
- When extending schemas, run `bun run db:generate` to create migrations

### When working with API routes

- Place routes in the `src/app/api/` directory following Next.js App Router conventions
- Use proper HTTP methods (GET, POST, PUT, DELETE) for RESTful operations
- Implement proper error handling and status codes (200, 201, 400, 404, 500)
- Validate all input data using Zod schemas from `src/schema/`
- Return JSON responses with consistent structure
- Implement proper authentication checks for protected endpoints
- Use NextResponse for consistent response handling

### When working with authentication

- Use Clerk's authentication utilities and React hooks
- Protect pages using middleware configuration in `middleware.ts`
- Implement proper redirects for authentication states
- Use Clerk components for sign-in/sign-up flows
- Access user information through Clerk's auth context

## Available scripts and commands

Make Windsurf aware of the available development commands to provide accurate guidance on running tasks:

- `bun run dev` - Start the development server
- `bun run build` - Create a production build
- `bun run start` - Start the production server
- `bun run lint` - Run ESLint for code quality checks
- `bun run format` - Format code with Prettier
- `bun run db:push` - Push schema changes directly to database (development only)
- `bun run db:generate` - Generate migrations from schema changes
- `bun run db:migrate` - Apply migrations to the database
- `bun run db:studio` - Open Drizzle Studio for database management
- `bun run db:seed` - Seed the database with sample data

## Common StackForge tasks with examples

### Creating a new page

1. Create a new directory in `src/app/` following the route group structure
2. Add a `page.tsx` file with the page content using TypeScript
3. Add a `layout.tsx` file if needed for page-specific layouts
4. Implement proper TypeScript typing for props and state
5. Use Tailwind CSS for styling with the established design system
6. Use server components for data fetching when possible
7. Implement proper error handling and loading states

Example page structure:
```tsx
// src/app/(main)/example/page.tsx
import { ExampleComponent } from "@/components/example";

export default function ExamplePage() {
  return (
    <div className="container py-8">
      <h1 className="text-2xl font-bold">Example Page</h1>
      <ExampleComponent />
    </div>
  );
}
```

### Creating a new component

1. Determine the appropriate directory in `src/components/` based on component purpose
2. Create a new `.tsx` file with the component using TypeScript
3. Use TypeScript interfaces for props with explicit typing
4. Implement the component with proper error handling and accessibility
5. Use Tailwind CSS for styling following the design system
6. Export the component properly for use in other files
7. Add the component to the relevant `index.ts` export file

Example component structure:
```tsx
// src/components/example/example-component.tsx
import { cn } from "@/functions";

interface ExampleComponentProps {
  title: string;
  description?: string;
  className?: string;
}

export function ExampleComponent({ 
  title, 
  description, 
  className 
}: ExampleComponentProps) {
  return (
    <div className={cn("p-4 rounded-lg border", className)}>
      <h2 className="text-xl font-semibold">{title}</h2>
      {description && <p className="text-muted-foreground">{description}</p>}
    </div>
  );
}
```

### Creating a new database model

1. Create a new file in `src/db/schema/` for the model
2. Define the table using Drizzle ORM's `pgTable` function
3. Add relations if needed using Drizzle's `relations` function
4. Export the model and relations
5. Add the model to the schema index file at `src/db/schema/index.ts`
6. Run `bun run db:generate` to create the migration
7. Run `bun run db:migrate` to apply the migration to your database

Example database model:
```ts
// src/db/schema/example.ts
import { pgTable, text, timestamp, uuid } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
import { users } from './user';

export const examples = pgTable('examples', {
  id: uuid('id').defaultRandom().primaryKey(),
  userId: uuid('user_id')
    .notNull()
    .references(() => users.id),
  title: text('title').notNull(),
  content: text('content'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

export const examplesRelations = relations(examples, ({ one }) => ({
  user: one(users, {
    fields: [examples.userId],
    references: [users.id],
  }),
}));
```

### Creating an API route

1. Create a new directory in `src/app/api/` for the route
2. Add a `route.ts` file with the API implementation
3. Use proper HTTP methods (GET, POST, PUT, DELETE)
4. Implement input validation with Zod schemas
5. Handle errors appropriately with try/catch blocks
6. Return JSON responses with proper status codes

Example API route:
```ts
// src/app/api/examples/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { examples } from '@/db/schema';
import { exampleSchema } from '@/schema';

export async function POST(request: Request) {
  try {
    const body = await request.json();
    const validatedData = exampleSchema.parse(body);
    
    const [newExample] = await db.insert(examples).values(validatedData).returning();
    
    return NextResponse.json(newExample, { status: 201 });
  } catch (error) {
    console.error('Error creating example:', error);
    return NextResponse.json(
      { error: 'Failed to create example' }, 
      { status: 500 }
    );
  }
}
```