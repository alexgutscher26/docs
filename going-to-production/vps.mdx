---
title: 'Deploy to a VPS'
description: 'Deploy your StackForge application to a VPS'
---

# Deploy to a VPS

This guide will help you deploy your StackForge application to a VPS (Virtual Private Server). This guide uses DigitalOcean as an example, but the steps apply to other platforms like Hetzner, Linode, Vultr, etc.

## Overview

Self-hosting your StackForge application on a VPS gives you maximum control over your infrastructure and data. This guide covers setting up a production-ready environment on a VPS.

## Prerequisites

1. VPS with at least 2GB RAM and 2 CPU cores
2. Ubuntu 20.04 or later (other Linux distributions work similarly)
3. Root or sudo access to the VPS
4. Git installed on the VPS
5. Domain name (optional but recommended)

## Deployment Steps

### 1. Create a VPS Instance

From your preferred cloud provider (DigitalOcean, AWS, Google Cloud, etc.), create a new instance with:

- **OS**: Ubuntu 20.04 or later
- **CPU**: At least 2 cores
- **RAM**: At least 2GB
- **Storage**: At least 20GB SSD

### 2. Install Docker

Connect to your VPS via SSH and install Docker:

```bash
# Update package index
sudo apt update

# Install Docker
sudo apt install docker.io docker-compose -y

# Start and enable Docker
sudo systemctl start docker
sudo systemctl enable docker

# Add current user to docker group
sudo usermod -aG docker $USER

# Log out and log back in for group changes to take effect
```

### 3. Add Firewall Rules

Configure firewall to allow inbound traffic:

```bash
# Allow SSH (port 22)
sudo ufw allow ssh

# Allow HTTP (port 80)
sudo ufw allow http

# Allow HTTPS (port 443)
sudo ufw allow https

# Enable firewall
sudo ufw enable
```

### 4. Clone Your Repository

Clone your StackForge repository to the VPS:

```bash
# Install Git if not already installed
sudo apt install git -y

# Clone your repository
git clone https://github.com/your-username/stackforge.git
cd stackforge
```

### 5. Create Docker Configuration

Create a Dockerfile for your StackForge application:

```dockerfile
# Dockerfile
FROM oven/bun:1 AS base

# Install dependencies
WORKDIR /app
COPY package.json bun.lock ./
RUN bun install --production

# Copy source code
COPY . .

# Build the application
RUN bun run build

# Production stage
FROM oven/bun:1-deps AS production

WORKDIR /app

# Copy built application
COPY --from=base /app/.next ./.next
COPY --from=base /app/node_modules ./node_modules
COPY --from=base /app/package.json ./package.json

# Expose port
EXPOSE 3000

# Start the application
CMD ["bun", "run", "start"]
```

### 6. Create Docker Compose File

Create a docker-compose.yml file for easier management:

```yaml
# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - '3000:3000'
    environment:
      - NODE_ENV=production
      - NEXT_PUBLIC_APP_NAME=${NEXT_PUBLIC_APP_NAME}
      - NEXT_PUBLIC_APP_DOMAIN=${NEXT_PUBLIC_APP_DOMAIN}
      - DATABASE_URL=${DATABASE_URL}
      - NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=${NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}
      - CLERK_SECRET_KEY=${CLERK_SECRET_KEY}
      - NEXT_PUBLIC_CLERK_SIGN_IN_URL=${NEXT_PUBLIC_CLERK_SIGN_IN_URL}
      - NEXT_PUBLIC_CLERK_SIGN_UP_URL=${NEXT_PUBLIC_CLERK_SIGN_UP_URL}
      - NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_URL=${NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_URL}
      - NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_URL=${NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_URL}
    env_file:
      - .env.production
    restart: unless-stopped

  # Optional: nginx reverse proxy
  nginx:
    image: nginx:alpine
    ports:
      - '80:80'
      - '443:443'
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
```

### 7. Environment Variables

Create a production environment file:

```bash
# Create .env.production file
cat > .env.production << EOF
# App Configuration
NEXT_PUBLIC_APP_NAME=YourAppName
NEXT_PUBLIC_APP_DOMAIN=https://yourdomain.com

# Database
DATABASE_URL=postgresql://user:password@localhost:5432/stackforge_production

# Clerk Authentication
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY=pk_live_XXXXXXXXXXXXXXXXXXXXXXXX
CLERK_SECRET_KEY=sk_live_XXXXXXXXXXXXXXXXXXXXXXXX
NEXT_PUBLIC_CLERK_SIGN_IN_URL=/auth/signin
NEXT_PUBLIC_CLERK_SIGN_UP_URL=/auth/signup
NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_URL=/
NEXT_PUBLIC_CLERK_SIGN_UP_FALLBACK_URL=/

# Optional variables
RESEND_API_KEY=your_resend_api_key
EOF
```

### 8. Build and Run the Application

Build and run your StackForge application:

```bash
# Build the Docker image
docker-compose build

# Start the application
docker-compose up -d
```

## Production Database Setup

### Option 1: PostgreSQL in Docker

Add PostgreSQL to your docker-compose.yml:

```yaml
# Add to docker-compose.yml
version: '3.8'

services:
  app:
    # ... existing app configuration ...

  db:
    image: postgres:15
    environment:
      POSTGRES_DB: stackforge_production
      POSTGRES_USER: stackforge_user
      POSTGRES_PASSWORD: secure_password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  # ... other services ...

volumes:
  postgres_data:
```

### Option 2: External Database

Use an external PostgreSQL database service like:

- AWS RDS
- Google Cloud SQL
- DigitalOcean PostgreSQL cluster
- Self-hosted PostgreSQL

## Reverse Proxy Configuration

### Nginx Configuration

Create an nginx.conf file for reverse proxy:

```nginx
# nginx.conf
events {
    worker_connections 1024;
}

http {
    upstream app {
        server app:3000;
    }

    server {
        listen 80;
        server_name yourdomain.com;

        location / {
            proxy_pass http://app;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
        }
    }
}
```

## SSL Certificate Setup

### Using Let's Encrypt with Certbot

Install Certbot and obtain SSL certificates:

```bash
# Install Certbot
sudo apt install certbot python3-certbot-nginx -y

# Obtain SSL certificate
sudo certbot --nginx -d yourdomain.com

# Auto-renew certificates
sudo crontab -e
# Add this line to renew certificates twice daily:
# 0 12 * * * /usr/bin/certbot renew --quiet
```

## Monitoring and Maintenance

### Health Checks

Implement health checks for your application:

```ts
// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { sql } from 'drizzle-orm';

export async function GET() {
  try {
    // Simple database query to check connectivity
    await db.execute(sql`SELECT 1`);

    return NextResponse.json({ status: 'ok', database: 'connected' });
  } catch (error) {
    return NextResponse.json(
      { status: 'error', database: 'disconnected' },
      { status: 500 }
    );
  }
}
```

### Log Management

Set up log rotation to prevent disk space issues:

```bash
# Create logrotate configuration
sudo tee /etc/logrotate.d/stackforge << EOF
/home/youruser/stackforge/*.log {
    daily
    missingok
    rotate 52
    compress
    delaycompress
    notifempty
    create 644 youruser youruser
}
EOF
```

### Automated Backups

Set up automated database backups:

```bash
#!/bin/bash
# backup.sh
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"
DB_NAME="stackforge_production"
DB_USER="stackforge_user"

# Create backup
pg_dump -U $DB_USER -h localhost $DB_NAME > $BACKUP_DIR/backup_$DATE.sql

# Compress backup
gzip $BACKUP_DIR/backup_$DATE.sql

# Remove backups older than 30 days
find $BACKUP_DIR -name "backup_*.sql.gz" -mtime +30 -delete
```

## Security Considerations

### SSH Security

Secure your SSH access:

```bash
# Edit SSH configuration
sudo nano /etc/ssh/sshd_config

# Recommended settings:
# Port 2222  # Change default port
# PermitRootLogin no
# PasswordAuthentication no  # Use SSH keys only
# AllowUsers youruser

# Restart SSH service
sudo systemctl restart ssh
```

### Application Security

1. **Use Strong Passwords**: For database and other services
2. **Keep Software Updated**: Regularly update OS and dependencies
3. **Limit Network Access**: Use firewall rules to restrict access
4. **Monitor Logs**: Regularly check logs for suspicious activity

## Performance Optimization

### Resource Monitoring

Monitor system resources:

```bash
# Install htop for system monitoring
sudo apt install htop -y

# Monitor Docker containers
docker stats

# Check system resources
htop
```

### Caching Strategy

Implement caching for better performance:

```ts
// src/lib/cache.ts
import { unstable_cache } from 'next/cache';

export const getCachedPosts = unstable_cache(
  async () => {
    const posts = await db.query.posts.findMany();
    return posts;
  },
  ['posts'],
  { revalidate: 60 } // Cache for 1 minute
);
```

## Troubleshooting

### Common Issues

1. **Port Already in Use**: Check if port 3000 is already occupied
2. **Database Connection Issues**: Verify database credentials and connectivity
3. **Insufficient Memory**: Upgrade your VPS if experiencing out-of-memory errors
4. **Permission Issues**: Ensure proper file permissions

### Debugging Steps

1. **Check Docker Logs**:

   ```bash
   docker-compose logs app
   ```

2. **Check Application Health**:

   ```bash
   curl http://localhost:3000/api/health
   ```

3. **Verify Environment Variables**:

   ```bash
   docker-compose exec app env
   ```

4. **Check System Resources**:
   ```bash
   docker stats
   ```

## Next Steps

<CardGroup cols={2}>

<Card
  title="Production Checklist"
  icon="check-circle"
  href="/going-to-production/production-checklist"
>
  Complete the production checklist
</Card>

<Card
  title="Database Setup"
  icon="database"
  href="/going-to-production/database-setup"
>
  Configure your production database
</Card>

</CardGroup>
