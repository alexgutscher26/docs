---
title: 'Database Setup'
description: 'Configure your StackForge production PostgreSQL database'
---

# Database Setup

Setting up a production PostgreSQL database is crucial for the performance, security, and reliability of your StackForge application. This guide covers everything you need to know about configuring your production database.

## Production Database Options

### PostgreSQL Providers

Choose from these popular PostgreSQL providers for production:

1. **Supabase** - Recommended for ease of use and built-in features
2. **Neon** - Serverless PostgreSQL with auto-scaling
3. **Railway** - Developer-friendly database platform
4. **AWS RDS** - Enterprise-grade managed PostgreSQL
5. **Google Cloud SQL** - Google's managed database service
6. **Self-hosted** - Maximum control and customization

## Database Configuration

### Connection String

Your production database connection string should follow this format:

```env
DATABASE_URL=postgresql://username:password@host:port/database_name
```

Example:
```env
DATABASE_URL=postgresql://stackforge_user:secure_password@db.example.com:5432/stackforge_production
```

### Connection Pooling

Use connection pooling for better performance in production:

```ts
// src/db/index.ts
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

// For production, use connection pooling
const client = postgres(process.env['DATABASE_URL']!, {
  max: 20, // Maximum connections
  idle_timeout: 20, // Close idle connections after 20 seconds
  max_lifetime: 60 * 60, // Close connections after 1 hour
});

export const db = drizzle(client, { schema });
```

## Security Configuration

### Database User Permissions

Create a dedicated database user with minimal required permissions:

```sql
-- Create a dedicated user for the application
CREATE USER stackforge_app WITH PASSWORD 'secure_password';

-- Grant necessary permissions
GRANT CONNECT ON DATABASE stackforge_production TO stackforge_app;
GRANT USAGE ON SCHEMA public TO stackforge_app;
GRANT SELECT, INSERT, UPDATE, DELETE ON ALL TABLES IN SCHEMA public TO stackforge_app;
GRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO stackforge_app;

-- Grant permissions for future tables
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT, INSERT, UPDATE, DELETE ON TABLES TO stackforge_app;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT USAGE, SELECT ON SEQUENCES TO stackforge_app;
```

### SSL Configuration

Enable SSL for secure database connections:

```ts
// src/db/index.ts
const client = postgres(process.env['DATABASE_URL']!, {
  ssl: {
    rejectUnauthorized: true,
  },
});
```

### Environment Variables

Store database credentials securely in environment variables:

```env
# Production Database Configuration
DATABASE_URL=postgresql://stackforge_user:secure_password@db.example.com:5432/stackforge_production?sslmode=require
```

## Performance Optimization

### Indexes

Create appropriate indexes for better query performance:

```ts
// src/db/schema/post.ts
import { pgTable, serial, text, timestamp, boolean, integer } from 'drizzle-orm/pg-core';
import { users } from './user';

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content'),
  published: boolean('published').default(false),
  authorId: integer('author_id').references(() => users.id),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => {
  return {
    // Indexes for better performance
    authorIdIdx: index('posts_author_id_idx').on(table.authorId),
    publishedIdx: index('posts_published_idx').on(table.published),
    createdAtIdx: index('posts_created_at_idx').on(table.createdAt),
  };
});
```

### Query Optimization

Optimize your database queries:

```ts
// src/app/api/posts/route.ts
import { db } from '@/db';
import { posts, users } from '@/db/schema';
import { desc, eq } from 'drizzle-orm';

export async function GET() {
  try {
    // Optimized query with joins and limits
    const result = await db.select({
      id: posts.id,
      title: posts.title,
      content: posts.content,
      published: posts.published,
      createdAt: posts.createdAt,
      author: {
        id: users.id,
        name: users.name,
      },
    })
    .from(posts)
    .leftJoin(users, eq(posts.authorId, users.id))
    .orderBy(desc(posts.createdAt))
    .limit(50); // Limit results for better performance

    return NextResponse.json(result);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch posts' },
      { status: 500 }
    );
  }
}
```

## Backup and Recovery

### Automated Backups

Set up automated backups for your database:

#### Supabase Backups

Supabase provides automated backups:
1. Go to your Supabase project dashboard
2. Navigate to "Database" > "Backups"
3. Configure backup schedule and retention

#### Manual Backup Script

Create a backup script for self-hosted databases:

```bash
#!/bin/bash
# backup.sh
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"
DB_NAME="stackforge_production"
DB_USER="stackforge_user"

# Create backup
pg_dump -U $DB_USER -h localhost $DB_NAME > $BACKUP_DIR/backup_$DATE.sql

# Compress backup
gzip $BACKUP_DIR/backup_$DATE.sql

# Remove backups older than 30 days
find $BACKUP_DIR -name "backup_*.sql.gz" -mtime +30 -delete
```

### Point-in-Time Recovery

Configure point-in-time recovery (PITR):

```bash
# Enable WAL archiving in postgresql.conf
wal_level = replica
archive_mode = on
archive_command = 'cp %p /wal_archive/%f'
```

### Disaster Recovery Plan

Create a disaster recovery plan:

1. **Regular Backups**: Daily full backups, hourly WAL archives
2. **Off-site Storage**: Store backups in multiple locations
3. **Recovery Testing**: Regularly test backup restoration
4. **Documentation**: Document recovery procedures
5. **Monitoring**: Monitor backup success and database health

## Migration Management

### Production Migrations

Apply database migrations to production:

```bash
# Generate migrations from schema changes
bun run db:generate

# Apply migrations to production database
bun run db:migrate
```

### Migration Rollbacks

Prepare for migration rollbacks:

```ts
// drizzle/migrations/meta/0001_rollback.sql
-- Rollback script for migration 0001
ALTER TABLE posts DROP COLUMN IF EXISTS new_column;
```

### Zero-Downtime Migrations

For zero-downtime deployments:

1. **Backward Compatible Changes**: Make schema changes backward compatible
2. **Multi-Step Deployments**: Deploy code and schema changes separately
3. **Feature Flags**: Use feature flags for new functionality

## Monitoring and Maintenance

### Database Monitoring

Monitor database performance and health:

```sql
-- Monitor active connections
SELECT count(*) FROM pg_stat_activity;

-- Monitor slow queries
SELECT query, mean_time, calls 
FROM pg_stat_statements 
ORDER BY mean_time DESC 
LIMIT 10;
```

### Health Checks

Implement database health checks:

```ts
// src/app/api/health/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { sql } from 'drizzle-orm';

export async function GET() {
  try {
    // Simple database query to check connectivity
    await db.execute(sql`SELECT 1`);
    
    return NextResponse.json({ status: 'ok', database: 'connected' });
  } catch (error) {
    return NextResponse.json(
      { status: 'error', database: 'disconnected' },
      { status: 500 }
    );
  }
}
```

### Maintenance Tasks

Schedule regular maintenance tasks:

```sql
-- Update table statistics
ANALYZE;

-- Reindex tables
REINDEX TABLE posts;

-- Vacuum tables
VACUUM ANALYZE posts;
```

## Scaling Considerations

### Read Replicas

Set up read replicas for read-heavy workloads:

```ts
// src/db/read-replica.ts
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

const readReplicaClient = postgres(process.env['DATABASE_READ_REPLICA_URL']!);
export const readReplicaDb = drizzle(readReplicaClient, { schema });
```

### Connection Management

Manage database connections efficiently:

```ts
// src/db/index.ts
const client = postgres(process.env['DATABASE_URL']!, {
  max: 20, // Adjust based on your needs
  connectionTimeoutMillis: 5000,
  idleTimeoutMillis: 30000,
});
```

### Caching Strategy

Implement caching to reduce database load:

```ts
// src/lib/cache.ts
import { unstable_cache } from 'next/cache';

export const getCachedPosts = unstable_cache(
  async () => {
    const posts = await db.query.posts.findMany();
    return posts;
  },
  ['posts'],
  { revalidate: 60 } // Cache for 1 minute
);
```

## Troubleshooting

### Common Issues

1. **Connection Timeouts**: Check network connectivity and firewall rules
2. **Permission Errors**: Verify user permissions and database ownership
3. **SSL Issues**: Ensure SSL certificates are valid and properly configured
4. **Performance Problems**: Check for missing indexes and inefficient queries

### Debugging Database Issues

1. **Check Logs**: Review database logs for errors
2. **Monitor Connections**: Check for connection leaks
3. **Analyze Queries**: Use `EXPLAIN` to analyze query performance
4. **Test Connectivity**: Verify database connectivity from your application

### Database Health Checks

Implement comprehensive health checks:

```ts
// src/lib/database-health.ts
export async function checkDatabaseHealth() {
  try {
    // Test basic connectivity
    await db.execute(sql`SELECT 1`);
    
    // Test specific table access
    await db.query.posts.findFirst();
    
    // Test write operations
    await db.insert(testTable).values({ test: 'health-check' });
    await db.delete(testTable).where(eq(testTable.test, 'health-check'));
    
    return { status: 'healthy' };
  } catch (error) {
    return { status: 'unhealthy', error: error.message };
  }
}
```

## Next Steps

<CardGroup cols={2}>

<Card
  title="Production Checklist"
  icon="check-circle"
  href="/going-to-production/production-checklist"
>
  Complete the production checklist
</Card>

<Card
  title="Deployment Options"
  icon="cloud-arrow-up"
  href="/going-to-production/deployment-options"
>
  Choose the right deployment platform
</Card>

</CardGroup>