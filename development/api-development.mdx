---
title: 'API Development'
description: 'Learn how to build and extend API endpoints in StackForge'
---

# API Development

Learn how to build, extend, and manage API endpoints in StackForge. This guide covers the API architecture, best practices, and techniques for creating robust serverless functions.

## API Architecture

StackForge uses Next.js API Routes to create serverless functions that handle HTTP requests. These routes are located in the `src/app/api/` directory and follow the App Router conventions.

### Route Structure

API routes are organized by functionality:

```
src/app/api/
├── posts/
│   ├── route.ts        # GET /api/posts, POST /api/posts
│   └── [id]/
│       └── route.ts    # GET /api/posts/{id}, PUT /api/posts/{id}, DELETE /api/posts/{id}
├── users/
│   └── route.ts        # GET /api/users
└── route.ts            # Root API route
```

### Route Handlers

Each route file exports HTTP method handlers:

```ts
// src/app/api/posts/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { posts } from '@/db/schema';
import { eq } from 'drizzle-orm';

// GET /api/posts
export async function GET() {
  try {
    const allPosts = await db.query.posts.findMany();
    return NextResponse.json(allPosts);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch posts' },
      { status: 500 }
    );
  }
}

// POST /api/posts
export async function POST(request: Request) {
  try {
    const body = await request.json();

    const newPost = await db
      .insert(posts)
      .values({
        title: body.title,
        content: body.content,
        userId: body.userId,
      })
      .returning();

    return NextResponse.json(newPost[0], { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}
```

## Creating New API Routes

### Route File Structure

Create a new directory in `src/app/api/` and add a `route.ts` file:

```ts
// src/app/api/users/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { users } from '@/db/schema';

export async function GET() {
  try {
    const allUsers = await db.query.users.findMany();
    return NextResponse.json(allUsers);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    );
  }
}
```

### Dynamic Routes

Create dynamic routes using square brackets:

```ts
// src/app/api/posts/[id]/route.ts
import { NextResponse } from 'next/server';
import { db } from '@/db';
import { posts } from '@/db/schema';
import { eq } from 'drizzle-orm';

interface Params {
  id: string;
}

export async function GET(request: Request, { params }: { params: Params }) {
  try {
    const post = await db.query.posts.findFirst({
      where: eq(posts.id, parseInt(params.id)),
    });

    if (!post) {
      return NextResponse.json({ error: 'Post not found' }, { status: 404 });
    }

    return NextResponse.json(post);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch post' },
      { status: 500 }
    );
  }
}
```

## Request Handling

### Parsing Request Data

Parse JSON data from requests:

```ts
export async function POST(request: Request) {
  try {
    const body = await request.json();

    // Validate the request body
    const { title, content, userId } = body;

    if (!title || !content || !userId) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Process the data
    // ...
  } catch (error) {
    return NextResponse.json({ error: 'Invalid JSON' }, { status: 400 });
  }
}
```

### Handling Query Parameters

Parse query parameters from the request URL:

```ts
export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url);
    const limit = searchParams.get('limit');
    const offset = searchParams.get('offset');

    const posts = await db.query.posts.findMany({
      limit: limit ? parseInt(limit) : 10,
      offset: offset ? parseInt(offset) : 0,
    });

    return NextResponse.json(posts);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch posts' },
      { status: 500 }
    );
  }
}
```

## Response Handling

### JSON Responses

Return JSON responses with appropriate status codes:

```ts
// Success response
return NextResponse.json(
  { message: 'Post created successfully', post: newPost },
  { status: 201 }
);

// Error response
return NextResponse.json({ error: 'Post not found' }, { status: 404 });
```

### Custom Headers

Add custom headers to responses:

```ts
export async function GET() {
  const response = NextResponse.json(data);
  response.headers.set('Cache-Control', 's-maxage=1, stale-while-revalidate');
  return response;
}
```

## Database Integration

### Using Drizzle ORM

Integrate with the database using Drizzle ORM:

```ts
import { db } from '@/db';
import { posts, users } from '@/db/schema';
import { eq, desc } from 'drizzle-orm';

// Query multiple records
const recentPosts = await db.query.posts.findMany({
  orderBy: [desc(posts.createdAt)],
  limit: 10,
});

// Query with relations
const postWithAuthor = await db.query.posts.findFirst({
  where: eq(posts.id, postId),
  with: {
    user: true,
  },
});

// Insert records
const newPost = await db
  .insert(posts)
  .values({
    title: 'New Post',
    content: 'Post content',
    userId: 1,
  })
  .returning();

// Update records
const updatedPost = await db
  .update(posts)
  .set({ title: 'Updated Title' })
  .where(eq(posts.id, postId))
  .returning();

// Delete records
await db.delete(posts).where(eq(posts.id, postId));
```

### Error Handling

Handle database errors appropriately:

```ts
export async function POST(request: Request) {
  try {
    const body = await request.json();

    const newPost = await db
      .insert(posts)
      .values({
        title: body.title,
        content: body.content,
        userId: body.userId,
      })
      .returning();

    return NextResponse.json(newPost[0], { status: 201 });
  } catch (error: any) {
    if (error.code === '23505') {
      // Unique constraint violation
      return NextResponse.json(
        { error: 'Post with this title already exists' },
        { status: 409 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}
```

## Authentication and Authorization

### Protecting Routes

Protect API routes using Clerk authentication:

```ts
import { auth } from '@clerk/nextjs/server';

export async function POST(request: Request) {
  const { userId } = auth();

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Continue with authenticated logic
  // ...
}
```

### Role-Based Access Control

Implement role-based access control:

```ts
import { auth } from '@clerk/nextjs/server';

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  const { userId, sessionClaims } = auth();

  if (!userId) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  // Check if user has admin role
  const isAdmin = (sessionClaims?.metadata as any)?.role === 'admin';

  if (!isAdmin) {
    return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
  }

  // Continue with admin-only logic
  // ...
}
```

## Validation and Error Handling

### Using Zod for Validation

Validate request data using Zod schemas:

```ts
import { z } from 'zod';

const PostSchema = z.object({
  title: z.string().min(1).max(100),
  content: z.string().min(1),
  userId: z.number().positive(),
});

export async function POST(request: Request) {
  try {
    const body = await request.json();

    // Validate the request body
    const validatedData = PostSchema.parse(body);

    // Process validated data
    // ...
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Validation failed', details: error.errors },
        { status: 400 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}
```

### Error Response Format

Use consistent error response formats:

```ts
interface ErrorResponse {
  error: string;
  details?: any;
  timestamp?: string;
}

function createErrorResponse(
  error: string,
  status: number,
  details?: any
): NextResponse<ErrorResponse> {
  return NextResponse.json(
    {
      error,
      details,
      timestamp: new Date().toISOString(),
    },
    { status }
  );
}

// Usage
return createErrorResponse('Post not found', 404);
```

## Testing API Routes

### Writing API Tests

Create test files for API routes:

```ts
// src/app/api/posts/route.test.ts
import { GET, POST } from './route';
import { NextResponse } from 'next/server';

// Mock the database
jest.mock('@/db', () => ({
  db: {
    query: {
      posts: {
        findMany: jest.fn(),
      },
    },
  },
}));

describe('POST /api/posts', () => {
  it('should create a new post', async () => {
    const request = new Request('http://localhost/api/posts', {
      method: 'POST',
      body: JSON.stringify({
        title: 'Test Post',
        content: 'Test content',
        userId: 1,
      }),
    });

    const response = await POST(request);
    const data = await response.json();

    expect(response.status).toBe(201);
    expect(data.title).toBe('Test Post');
  });
});
```

### Testing Best Practices

1. Mock external dependencies
2. Test different HTTP methods
3. Test error cases
4. Test validation scenarios
5. Use realistic test data

## Performance Optimization

### Caching

Implement caching for improved performance:

```ts
import { unstable_cache } from 'next/cache';

const getCachedPosts = unstable_cache(
  async () => {
    return await db.query.posts.findMany();
  },
  ['posts'],
  { revalidate: 60 } // Revalidate every 60 seconds
);

export async function GET() {
  try {
    const posts = await getCachedPosts();
    return NextResponse.json(posts);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch posts' },
      { status: 500 }
    );
  }
}
```

### Rate Limiting

Implement rate limiting for public APIs:

```ts
import { Ratelimit } from '@upstash/ratelimit';
import { Redis } from '@upstash/redis';

const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, '10 s'),
});

export async function GET(request: Request) {
  const ip = request.headers.get('x-forwarded-for') ?? '127.0.0.1';

  const { success } = await ratelimit.limit(ip);

  if (!success) {
    return NextResponse.json({ error: 'Too many requests' }, { status: 429 });
  }

  // Continue with API logic
  // ...
}
```

## Security Best Practices

### Input Sanitization

Sanitize user input to prevent XSS attacks:

```ts
import sanitizeHtml from 'sanitize-html';

export async function POST(request: Request) {
  const body = await request.json();

  // Sanitize user input
  const sanitizedTitle = sanitizeHtml(body.title);
  const sanitizedContent = sanitizeHtml(body.content);

  // Use sanitized data
  // ...
}
```

### CORS Configuration

Configure CORS headers for API routes:

```ts
export async function GET() {
  const response = NextResponse.json(data);

  response.headers.set('Access-Control-Allow-Origin', '*');
  response.headers.set(
    'Access-Control-Allow-Methods',
    'GET, POST, PUT, DELETE'
  );
  response.headers.set(
    'Access-Control-Allow-Headers',
    'Content-Type, Authorization'
  );

  return response;
}
```

## Monitoring and Logging

### Logging

Implement logging for debugging and monitoring:

```ts
import { logger } from '@/lib/logger';

export async function POST(request: Request) {
  try {
    const body = await request.json();

    logger.info('Creating new post', { title: body.title });

    const newPost = await db.insert(posts).values(body).returning();

    logger.info('Post created successfully', { postId: newPost[0].id });

    return NextResponse.json(newPost[0], { status: 201 });
  } catch (error) {
    logger.error('Failed to create post', { error });

    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}
```

### Error Tracking

Integrate with error tracking services:

```ts
import * as Sentry from '@sentry/nextjs';

export async function POST(request: Request) {
  try {
    // API logic
  } catch (error) {
    Sentry.captureException(error);

    return NextResponse.json(
      { error: 'Failed to create post' },
      { status: 500 }
    );
  }
}
```

## Best Practices

### API Design

1. Use RESTful conventions
2. Return appropriate HTTP status codes
3. Provide meaningful error messages
4. Implement proper validation
5. Use consistent response formats

### Performance

1. Implement caching where appropriate
2. Optimize database queries
3. Use pagination for large datasets
4. Minimize payload sizes
5. Implement rate limiting

### Security

1. Validate all input data
2. Implement authentication and authorization
3. Use HTTPS in production
4. Sanitize user input
5. Implement proper error handling

## Troubleshooting

### Common Issues

1. **CORS errors**: Check CORS headers and origin configuration
2. **Database connection issues**: Verify database credentials and connection
3. **Authentication failures**: Check auth tokens and session management
4. **Validation errors**: Ensure request data matches schema requirements

### Debugging API Issues

1. Check server logs for error messages
2. Use Postman or curl to test API endpoints
3. Verify database queries are working correctly
4. Check environment variables are properly configured

## Next Steps

<CardGroup cols={2}>

<Card
  title="Database Management"
  icon="database"
  href="/development/database-management"
>
  Learn how to work with the database schema and migrations
</Card>

<Card title="Testing" icon="test-tube" href="/development/testing">
  Learn how to write and run tests for your application
</Card>

</CardGroup>
